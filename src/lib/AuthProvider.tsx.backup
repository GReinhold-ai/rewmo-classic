// src/lib/AuthProvider.tsx
// UPDATED: Uses redirect instead of popup for Google sign-in
import React, { createContext, useContext, useEffect, useMemo, useState } from "react";
import {
  GoogleAuthProvider,
  signInWithRedirect,
  getRedirectResult,
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  User,
} from "firebase/auth";
import { doc, getDoc, setDoc, serverTimestamp } from "firebase/firestore";
import { auth, db } from "@/lib/firebaseClient";
import { logRewardHistory } from "@/utils/logRewardHistory";

export type AuthContextType = {
  currentUser: User | null;
  getIdToken: () => Promise<string | null>;
  authHeader: () => Promise<Record<string, string>>;
  signInWithGoogle: () => Promise<void>;
  signInWithEmail: (email: string, password: string) => Promise<void>;
  signUpWithEmail: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  // üß† UNIFIED: Create/Update Firestore user document
  const ensureUserDocument = async (user: User): Promise<void> => {
    try {
      console.log('üî• [AuthProvider] Ensuring user document for:', user.uid, user.email);
      
      const userRef = doc(db, "users", user.uid);
      const docSnap = await getDoc(userRef);

      if (!docSnap.exists()) {
        console.log('üìù [AuthProvider] Creating NEW user document...');
        
        // Get referral code from localStorage (if exists)
        const referredBy = typeof window !== "undefined" 
          ? localStorage.getItem("rewmo_ref_code") || null 
          : null;

        const userData = {
          uid: user.uid,
          email: user.email || "",
          displayName: user.displayName || user.email?.split('@')[0] || "User",
          photoURL: user.photoURL || null,
          createdAt: serverTimestamp(),
          lastLoginAt: serverTimestamp(),
          
          // Rewards & Tier
          rewardPoints: 0,
          rewards: 0,
          membershipTier: "Silver",
          tier: "FREE",
          goal: 10000,
          
          // Referrals
          referralCode: `REF-${user.uid.slice(0, 8)}`,
          referredBy,
          referralCount: 0,
        };

        await setDoc(userRef, userData);
        console.log('‚úÖ [AuthProvider] User document created successfully:', userData);
      } else {
        console.log('‚úÖ [AuthProvider] User document already exists, updating lastLoginAt');
        
        // Update last login timestamp
        await setDoc(userRef, {
          lastLoginAt: serverTimestamp(),
        }, { merge: true });
        
        console.log('‚úÖ [AuthProvider] lastLoginAt updated');
      }
    } catch (error: any) {
      console.error('‚ùå [AuthProvider] ERROR creating/updating user document:', {
        error: error.message,
        code: error.code,
        userId: user.uid,
        userEmail: user.email,
      });
    }
  };

  // üéØ Handle Referral Tracking
  const handleReferralTracking = async (newUser: User): Promise<void> => {
    const referrerId = typeof window !== "undefined" 
      ? localStorage.getItem("rewmo_ref_code") 
      : null;
      
    if (!referrerId) {
      console.log('‚ÑπÔ∏è [AuthProvider] No referrer found, skipping referral tracking');
      return;
    }

    console.log('üéÅ [AuthProvider] Processing referral:', {
      referrerId,
      newUserId: newUser.uid,
      newUserEmail: newUser.email,
    });

    try {
      const response = await fetch(
        "https://us-central1-rewmoai.cloudfunctions.net/handleReferral",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            referrerId,
            newUserId: newUser.uid,
            newUserEmail: newUser.email,
          }),
        }
      );

      if (!response.ok) {
        throw new Error(`Referral API failed: ${response.status}`);
      }

      console.log('‚úÖ [AuthProvider] Referral tracking successful');

      // üéÅ Log rewards
      await logRewardHistory({
        userId: referrerId,
        type: "referral_bonus",
        description: `Referred user: ${newUser.email}`,
        points: 1000,
      });

      await logRewardHistory({
        userId: newUser.uid,
        type: "referral_signup_bonus",
        description: `Signed up using referral from ${referrerId}`,
        points: 500,
      });

      console.log('‚úÖ [AuthProvider] Reward history logged');

      // Clear referrer from localStorage
      if (typeof window !== "undefined") {
        localStorage.removeItem("rewmo_ref_code");
      }
    } catch (err: any) {
      console.error("‚ùå [AuthProvider] Referral tracking failed:", err.message);
    }
  };

  // üîê Google Sign-In with REDIRECT (more reliable than popup)
  const signInWithGoogle = async (): Promise<void> => {
    try {
      console.log('üîê [AuthProvider] Starting Google sign-in (redirect method)...');
      
      const provider = new GoogleAuthProvider();
      provider.setCustomParameters({ 
        prompt: "select_account",
        // Add these for better mobile support
        display: 'popup',
      });
      
      // Use redirect instead of popup - more reliable!
      await signInWithRedirect(auth, provider);
      // User will be redirected to Google, then back to your app
      // The redirect result is handled in useEffect below
      
    } catch (error: any) {
      console.error('‚ùå [AuthProvider] Google sign-in failed:', error.code, error.message);
      throw error;
    }
  };

  // üìß Email Sign-In
  const signInWithEmail = async (email: string, password: string): Promise<void> => {
    try {
      console.log('üìß [AuthProvider] Starting email sign-in for:', email);
      
      const result = await signInWithEmailAndPassword(auth, email, password);
      console.log('‚úÖ [AuthProvider] Email sign-in successful:', result.user.uid);
      
      await ensureUserDocument(result.user);
    } catch (error: any) {
      console.error('‚ùå [AuthProvider] Email sign-in failed:', error.code, error.message);
      throw error;
    }
  };

  // üÜï Email Sign-Up
  const signUpWithEmail = async (email: string, password: string): Promise<void> => {
    try {
      console.log('üÜï [AuthProvider] Starting email sign-up for:', email);
      
      const result = await createUserWithEmailAndPassword(auth, email, password);
      console.log('‚úÖ [AuthProvider] Email sign-up successful:', result.user.uid);
      
      await ensureUserDocument(result.user);
      await handleReferralTracking(result.user);
    } catch (error: any) {
      console.error('‚ùå [AuthProvider] Email sign-up failed:', error.code, error.message);
      throw error;
    }
  };

  // üö™ Logout
  const logout = async (): Promise<void> => {
    try {
      console.log('üö™ [AuthProvider] Logging out...');
      await signOut(auth);
      setCurrentUser(null);
      console.log('‚úÖ [AuthProvider] Logout successful');
    } catch (error: any) {
      console.error('‚ùå [AuthProvider] Logout failed:', error.message);
      throw error;
    }
  };

  // üëÅÔ∏è Auth State Listener + Handle Redirect Result
  useEffect(() => {
    console.log('üî• [AuthProvider] Setting up auth state listener...');
    
    // Check for redirect result first (after Google redirects back)
    getRedirectResult(auth)
      .then(async (result) => {
        if (result) {
          console.log('‚úÖ [AuthProvider] Google redirect sign-in successful:', result.user.uid);
          await ensureUserDocument(result.user);
          
          // Check if this is a new user for referral tracking
          const userRef = doc(db, "users", result.user.uid);
          const docSnap = await getDoc(userRef);
          
          if (docSnap.exists() && !docSnap.data().referredBy) {
            await handleReferralTracking(result.user);
          }
        }
      })
      .catch((error) => {
        console.error('‚ùå [AuthProvider] Redirect result error:', error);
      });
    
    // Set up auth state listener
    const unsubscribe = onAuthStateChanged(
      auth,
      async (user) => {
        console.log('üîÑ [AuthProvider] Auth state changed:', user ? user.uid : 'signed out');
        
        if (user) {
          await ensureUserDocument(user);
          setCurrentUser(user);
        } else {
          setCurrentUser(null);
        }
        
        setLoading(false);
      },
      (error) => {
        console.error('‚ùå [AuthProvider] Auth state change error:', error);
        setLoading(false);
      }
    );

    return () => {
      console.log('üî• [AuthProvider] Cleaning up auth state listener');
      unsubscribe();
    };
  }, []);

  // üîë Token Management
  const getIdToken = async (): Promise<string | null> => {
    try {
      if (!currentUser) {
        console.log('‚ÑπÔ∏è [AuthProvider] No current user, cannot get ID token');
        return null;
      }
      const token = await currentUser.getIdToken(false);
      console.log('‚úÖ [AuthProvider] ID token retrieved');
      return token;
    } catch (error: any) {
      console.error('‚ùå [AuthProvider] Failed to get ID token:', error.message);
      return null;
    }
  };

  const authHeader = async (): Promise<Record<string, string>> => {
    const token = await getIdToken();
    return token ? { Authorization: `Bearer ${token}` } : {};
  };

  const value = useMemo<AuthContextType>(
    () => ({
      currentUser,
      getIdToken,
      authHeader,
      signInWithGoogle,
      signInWithEmail,
      signUpWithEmail,
      logout,
    }),
    [currentUser]
  );

  // Don't render children until we've checked auth state
  if (loading) {
    return (
      <div style={{ 
        display: 'flex', 
        justifyContent: 'center', 
        alignItems: 'center', 
        height: '100vh' 
      }}>
        Loading...
      </div>
    );
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

export default AuthProvider;